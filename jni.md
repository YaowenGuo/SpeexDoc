_**这里的内容是jni编程的最基础介绍，例如生成头文件，链接。了解这是能更好的了解c和java之间的关系。而关于语法编程方面的内容，可以查看网上的帖子，例如：**_

https://www.jianshu.com/p/aba734d5b5cd

http://blog.csdn.net/freechao/article/details/7692239





JNI是Java Native Interface的缩写，它提供了若干的[API](https://baike.baidu.com/item/API/10154)实现了Java和其他语言的通信（主要是[C](https://baike.baidu.com/item/C/7252092)&[C++](https://baike.baidu.com/item/C%2B%2B)）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已[编译](https://baike.baidu.com/item/编译)语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码[交互](https://baike.baidu.com/item/交互/6964417)，通常会丧失平台[可移植性](https://baike.baidu.com/item/可移植性)。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证[本地代码](https://baike.baidu.com/item/本地代码)能工作在任何Java [虚拟机](https://baike.baidu.com/item/虚拟机)环境。

### JNI 包括相互调用的两部分：

* 允许你把一个[JVM](https://baike.baidu.com/item/JVM)嵌入到本地程序中。

* 本地程序可以链接一个实现了JVM的本地库，然后使用“调用接口”执行JAVA语言编写的软件模块。

### JNI的副作用

一旦使用JNI，JAVA程序就丧失了JAVA平台的两个优点：

1、程序不再[跨平台](https://baike.baidu.com/item/跨平台)

。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。

2、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个[类](https://baike.baidu.com/item/类/6824577)当中。这样就降低了JAVA和C之间的[耦合性](https://baike.baidu.com/item/耦合性)。

### 实现步骤

#### 1，使用 native 修饰一个想要在调用本地方法的抽象方法。

```java
// TestJni.java

package test;

public class TestJni {

    // 载入本地库
    static {
        System.out.println(System.getProperty("java.library.path"));
        // 1. 库文件名是　libhello.so，这里要写 hello. 不能带　lib 和　so 后缀
        // 2. 不能带路径，路径通过在运行的时候，-D 参数指定。如
        // java -Djava.library.path=. test.TestJni
        System.loadLibrary("hello");
    }
    // 所有使用native关键字修饰的都是对本地方法的声明。
    public native int displayHelloWorld();


    
    public static void main(String[] args) {
	    new TestJni().displayHelloWorld();
    }
}
```

声明[native](https://baike.baidu.com/item/native/13128691)方法：如果你想将一个方法做为一个本地[方法](https://baike.baidu.com/item/方法/3009367)的话，那么你就必须声明该方法为native的，并且不能实现。其中方法的参数和返回值在后面讲述。 Load动态库：System.loadLibrary\("hello"\);加载[动态库](https://baike.baidu.com/item/动态库)（我们可以这样理解：我们的方法 displayHelloWorld\(\)没有实现，但是我们在下面就直接使用了，所以必须在使用之前对它进行初始化）这里一般是以[static](https://baike.baidu.com/item/static)块进行加载的。同时需要注意的是System.[loadLibrary](https://baike.baidu.com/item/loadLibrary)\(\);的参数“hello”是动态库的名字。


#### ２．实现　Native 方法

既然要调用　C/C++ 的方法，Java 中声明的方法仅仅类似于一个接口，并没有实现代码。如何对应与一个　Native 方法呢？　Java 编译器能够生成用于　C++ 的头文件。

```shell
 javac -h . TestJni.java
```
生成的头文件 `test_TestJni.h`

```
// test_TestJni.h


/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class test_TestJni */

#ifndef _Included_test_TestJni
#define _Included_test_TestJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     test_TestJni
 * Method:    displayHelloWorld
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_test_TestJni_displayHelloWorld
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

（这里我们可以这样理解：这个h文件相当于我们在java里面的接口，这里声明了一个 `Java_test_TestJni_displayHelloWorld(JNIEnv *, jobject);
` 方法，然后在我们的本地方法里面实现这个方法，也就是说我们在编写[C/C++](https://baike.baidu.com/item/C%2FC%2B%2B)程序的时候所使用的方法名必须和这里的一致）。

在上面的代码中看到了JNIEXPORT和JNICALL关键字，这两个关键字是两个宏定义，他主要的作用就是说明该函数为JNI函数，在Java虚拟机加载的时候会链接对应的native方法，JNIEXPORT 表示输出类型；JNICALL表示参数的压栈顺序；貌似都可以省略.


仅需要将这里声明的方法实现即可

```C++
// HelloWord.c

#include <stdio.h>
#include <jni.h>

#include "test_TestJni.h"

JNIEXPORT jint JNICALL Java_test_TestJni_displayHelloWorld(JNIEnv * env, jobject obj)
{
    printf("%s", "Hello World");
    return 0;
}

```



jni.h是定义了很多我们使用的JNI函数和结构体，jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层，至于这些数据类型我们在后面介绍。这里的jint对应Java的int数据类型，该函数返回的int表示当前使用的JNI的版本，其实类似于Android系统的API版本一样，不同的JNI版本中定义的一些不同的JNI函数。该函数会有两个参数，其中 `*jvm` 为 `Java` 虚拟机实例，`JavaVM` 结构体定义了以下函数：


### 编译 C/C++ 为动态链接库

so动态链接库，so文件是linux下的c/c++动态链接库。Java虚拟机会在运行时动态加载so库，并运行。

```
gcc -I <指定头文件地址，这些函数的调用不会被链接进来，在运行时才动态调用> -fPIC -shared HelloWorld.c -o libtest.so
```
但是需要指定jni库和jni_mk库，一般在PATH里并没有配置。需要根据平台单独指定

在　Mac 上

```
gcc -I $JAVA_HOME/include  -I $JAVA_HOME/include/darwin/ HelloWorld.c -fPIC -shared -o libhello.so
```

JAVA_HOME:

```
/Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home

```
If you don't know where jni_md.h is, use `find`:

```
find / -name jni_md.h 2>/dev/null
```

Linux 上

```
gcc -I $JAVA_HOME/include -I $JAVA_HOME/include/linux HelloWorld.c -fPIC -shared -o libhello.so

```

###＃　编译运行　Java 代码

编译并没有什么特别

```
javac -d .　TestJni.java
```

运行　java 程序，此时必须指定要链接的　so　库的地址，因为它没有配置在 `java.library.path` 环境变量里。

```
java -Djava.library.path=. test.TestJni
```

输出　`Hello World`，这就是　Java 调用　C 的全部流程。






